<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GuessworkQuantumSideInfo.jl</title><link rel="canonical" href="https://ericphanson.github.io/GuessworkQuantumSideInfo.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GuessworkQuantumSideInfo.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Quick-example-1"><span>Quick example</span></a></li><li><a class="tocitem" href="#Guesswork-functions-1"><span>Guesswork functions</span></a></li><li><a class="tocitem" href="#Quantum-states-1"><span>Quantum states</span></a></li><li><a class="tocitem" href="#Utilities-1"><span>Utilities</span></a></li><li><a class="tocitem" href="#Ellipsoid-algorithm-functions-1"><span>Ellipsoid algorithm functions</span></a></li></ul></li><li><a class="tocitem" href="examples/">Examples</a></li><li><a class="tocitem" href="high-precision-example/">High precision example</a></li><li><a class="tocitem" href="mixed-integer-SDP/">Mixed-integer SDP example</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GuessworkQuantumSideInfo-1"><a class="docs-heading-anchor" href="#GuessworkQuantumSideInfo-1">GuessworkQuantumSideInfo</a><a class="docs-heading-anchor-permalink" href="#GuessworkQuantumSideInfo-1" title="Permalink"></a></h1><p>This is a package accompanying the preprint <a href="http://arxiv.org/abs/2001.03598"><em>Guesswork with Quantum Side Information</em></a>.</p><p>See the <a href="examples/#Examples-1">Examples</a> for some examples (or just below for a quick example), <a href="high-precision-example/#Computing-the-guesswork-to-high-precision-1">Computing the guesswork to high precision</a> for an example solving a problem with a high-precision SDP solver, <a href="mixed-integer-SDP/#Using-a-mixed-integer-SDP-to-find-extremal-strategies-1">Using a mixed-integer SDP to find extremal strategies</a> for an example using a mixed-integer SDP, or below for the documentation of the functions provided by this package.</p><h2 id="Quick-example-1"><a class="docs-heading-anchor" href="#Quick-example-1">Quick example</a><a class="docs-heading-anchor-permalink" href="#Quick-example-1" title="Permalink"></a></h2><p>Consider one party Alice who draws a random number in the set <code>[1,2,3,4]</code> uniformly at random. If she draws <code>1</code> she sends another party, Bob, the quantum state <code>|0⟩</code>; if she draws <code>2</code>, she sends <code>|1⟩</code>, if she draws <code>3</code> she sends <code>|-⟩</code>, and finally if she draws <code>4</code>, she sends <code>|+⟩</code>. Bob, knowing this general procedure but not which number Alice drew, aims to guess the value Alice drew by performing experiments on the quantum state he was given. The average number of guesses Bob needs in order to get the right answer, minimized over all quantum strategies, is the so-called <em>guesswork with quantum side information</em>. This package provides a means to compute this.</p><pre><code class="language-julia-repl">julia&gt; using GuessworkQuantumSideInfo, SCS

julia&gt; p = [0.25, 0.25, 0.25, 0.25];

julia&gt; ketzero = ket(1, 2);

julia&gt; ketone = ket(2, 2);

julia&gt; ketminus = (ket(1, 2) - ket(2,2))/sqrt(2);

julia&gt; ketplus = (ket(1, 2) + ket(2,2))/sqrt(2);

julia&gt; ρBs = dm.([ ketzero, ketone, ketminus, ketplus  ])
4-element Array{Array{Complex{Float64},2},1}:
 [1.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im]
 [0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]
 [0.4999999999999999 + 0.0im -0.4999999999999999 - 0.0im; -0.4999999999999999 + 0.0im 0.4999999999999999 + 0.0im]
 [0.4999999999999999 + 0.0im 0.4999999999999999 + 0.0im; 0.4999999999999999 + 0.0im 0.4999999999999999 + 0.0im]

julia&gt; output = guesswork(p, ρBs; solver = SCSSolver(verbose=false));

julia&gt; output.optval
1.7094231882324955</code></pre><h2 id="Guesswork-functions-1"><a class="docs-heading-anchor" href="#Guesswork-functions-1">Guesswork functions</a><a class="docs-heading-anchor-permalink" href="#Guesswork-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.guesswork" href="#GuessworkQuantumSideInfo.guesswork"><code>GuessworkQuantumSideInfo.guesswork</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">guesswork(
    p::AbstractVector{T},
    ρBs::AbstractVector{&lt;:AbstractMatrix};
    solver,
    K::Integer = length(p),
    c = T[1:K..., 5_000],
    dual::Bool = false,
    remove_repetition::Bool = true,
    povm_outcomes = make_povm_outcomes(length(p), K, remove_repetition),
    verbose::Bool = true,
)</code></pre><p>Computes the guesswork for the c-q state specified by a probability vector <code>p</code>, giving the distribution <code>X</code>, and <code>ρBs</code>, giving the associated quantum states.</p><p>The keyword arguments are as follows:</p><ul><li><code>solver</code> is the only required keyword argument; an SDP solver such as SCS or MOSEK must be passed.</li><li><code>K</code> corresponds to the maximum number of allowed guesses. The number of variables in the primal SDP (and the number of constraints in the dual SDP) scales as <code>length(p)^K</code>.</li><li><code>c</code> may be given a custom cost vector. If <code>K &lt; length(p)</code>, then <code>c</code> should be of length <code>K+1</code>. The last entry, <code>c[K+1]</code>, corresponds to the cost of not guessing the correct answer within <code>K</code> guesses.</li><li><code>dual</code> is a boolean variable indicating whether the primal or dual optimization problem should be solved.</li><li><code>remove_repetition</code> is a boolean variable defaulting to true, indicating whether repeated guesses of the same value should be removed; as long as <code>c</code> is increasing, this decreases the size of the SDP without affecting the optimal value.</li><li><code>povm_outcomes</code> should be an iterator (or vector) corresponding to the possible guessing orders. This defaults to all subsets of length <code>K</code> of <code>1:length(p)</code> without repetition.</li><li><code>verbose</code> is a boolean which indicates if warnings should be printed when the problem is not solved optimally.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/SDP_formulation.jl#LL78-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.guesswork_lower_bound" href="#GuessworkQuantumSideInfo.guesswork_lower_bound"><code>GuessworkQuantumSideInfo.guesswork_lower_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">guesswork_lower_bound(
    p::AbstractVector{T},
    ρBs::AbstractVector{&lt;:AbstractMatrix};
    solver,
    c = T[1:length(p)..., 10_000],
    verbose::Bool = false,
)</code></pre><p>See <a href="#GuessworkQuantumSideInfo.guesswork"><code>guesswork</code></a> for the meaning of the arguments. Computes a lower bound to the optimal expected number of guesses by solving a relaxed version of the primal SDP. For <code>J</code> states, only needs <code>J^2</code> PSD variables subject to two linear constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/lower_bound.jl#LL2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.guesswork_upper_bound" href="#GuessworkQuantumSideInfo.guesswork_upper_bound"><code>GuessworkQuantumSideInfo.guesswork_upper_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">guesswork_upper_bound(
    p::AbstractVector{T},
    ρBs::AbstractVector{&lt;:AbstractMatrix};
    make_solver,
    c::AbstractVector = T.(1:length(p)),
    max_retries = 50,
    max_time = Inf,
    num_constraints = Inf,
    verbose::Bool = false,
    num_steps_per_SA_run::Integer = length(p)^2 * 500,
) where {T&lt;:Number} -&gt; NamedTuple</code></pre><p>Computes an upper bound to the guesswork problem associated to the c-q state specified by <code>p</code> and <code>ρBs</code>, as in <a href="#GuessworkQuantumSideInfo.guesswork"><code>guesswork</code></a>. A custom cost vector <code>c</code> may be optionally passed. If the keyword argument <code>verbose</code> is set to true, information is printed about each iteration of the algorithm.</p><p>The keyword argument <code>make_solver</code> is required, and must pass a <em>function that creates a solver instances</em>. For example, instead of passing <code>SCSSolver()</code>, pass <code>() -&gt; SCSSolver()</code>. This is needed because the algorithm used in <code>guesswork_upper_bound</code> solves a sequence of SDPs, not just one.</p><p>The algorithm has three termination criteria which are controlled by keyword arguments. The algorithm stops when any of the following occur:</p><ul><li><code>max_retries</code> simulated annealing attempts fail to find a violated constraint.</li><li><code>num_constraints</code> constraints have been added to the dual SDP</li><li>The total runtime of the algorithm is projected to exceed <code>max_time</code> on the next iteration.</li></ul><p>By default, <code>max_retries</code> is set to 50, while <code>num_constraints</code> and <code>max_time</code> are set to infinity.</p><p>Lastly, the keyword argument <code>num_steps_per_SA_run</code> controls the runtime of the simulated annealing algorithm. Increase <code>num_steps_per_SA_run</code> to search longer for a violated constraint within a given simulated annealing run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/upper_bound.jl#LL1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.guesswork_ellipsoid" href="#GuessworkQuantumSideInfo.guesswork_ellipsoid"><code>GuessworkQuantumSideInfo.guesswork_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">guesswork_ellipsoid(p, ρBs; nl_solver, kwargs...) -&gt; NamedTuple</code></pre><p>Solves the guesswork SDP via a custom implementation of the ellipsoid algorithm. When provided a global optimizer for the <code>nl_solver</code> keyword (e.g. via EAGO.jl), this computes the value guesswork SDP. Keyword arguments are:</p><ul><li><code>nl_solver</code>: choice of nonlinear optimizer to use</li><li><code>c::AbstractVector = T.(1:length(p))</code>: choice of cost vector</li><li><code>deepcut = true</code>: whether to use &quot;deep cuts&quot; (can be faster)</li><li><code>tol = 1e-3</code>: solve tolerance (final value should be within <code>tol</code> of true solution)</li><li><code>max_time::TimePeriod</code>: provide an approximate upper limit on the duration of the solve (defaults to unlimited)</li><li><code>verbose::Bool = true</code>: whether to print timing information every so often to the terminal</li><li><code>timer_log_interval::Millisecond = Millisecond(1)*1e4</code>: how often to print timing information</li><li><code>logger = nothing</code>: provide a logger (such as via TensorBoardLogger.jl) to log information during a run.</li><li><code>normal_cone_tol = 0.0</code>: absolute tolerance to decide if a number is negative for the purpose of computing an element in the normal cone</li><li><code>perm_tol = 1e-4</code>: a relative tolerance to decide if a number is <code>1</code> for the purpose of finding permutations in the support of a doubly stochastic matrix</li><li><code>init_noise = 1e-6</code>: an amount of noise to add to the initial point to reduce symmetries</li><li><code>trace = true</code>: whether or not to store a trace of the center and shape of the ellipsoid, along with other parameters, at each step</li><li><code>max_SA_retries = 2</code>: a parameter to decide how many times to run a simulated annealing algorithm to find cuts before resorting to global optimization</li><li><code>num_steps_per_SA_run::Integer = length(p)^2 * 500</code>: how many steps to perform during each simulated annealing run</li><li><code>mutate! = rand_rev!</code>: mutation function for updating during the simulated annealing run</li><li><code>x = nothing</code>: initial center point of the ellipse (automatically chosen by <a href="#GuessworkQuantumSideInfo.default_init"><code>default_init</code></a> if left unspecified)</li><li><code>P = nothing</code>: initial shape of the ellipse (automatically chosen by <a href="#GuessworkQuantumSideInfo.default_init"><code>default_init</code></a> if left unspecified)</li></ul><p>To aid in resuming a previous run (after hitting a time limit or tightening <code>tol</code>), the following parameters may be passed:</p><ul><li><code>x_best = nothing</code>: </li><li><code>timer = TimerOutput()</code>: </li><li><code>cuts = Vector{Int}[]</code>: </li><li><code>iter = Ref(1)</code>: </li><li><code>f_best = Ref(T(Inf))</code>: </li><li><code>tracelog = []</code>: </li></ul><p>If <code>results = guesswork_ellipsoid(p, ρBs; nl_solver = ...)</code>, then <code>results.prob</code> holds the previous solution object. This run may be continued by <code>ellipsoid_algorithm!(results.prob; tol=...)</code> or fields may be passed here, e.g. <code>guesswork_ellipsoid(p, ρBs; x_best = results.prob.x_best, ...)</code>, or to the <a href="#GuessworkQuantumSideInfo.EllipsoidProblem"><code>EllipsoidProblem</code></a> constructor, e.g. <code>EllipsoidProblem(x_best = results.prob.x_best, ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/ellipsoid/ellipsoid_algorithm.jl#LL3-L42">source</a></section></article><h2 id="Quantum-states-1"><a class="docs-heading-anchor" href="#Quantum-states-1">Quantum states</a><a class="docs-heading-anchor-permalink" href="#Quantum-states-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.ket" href="#GuessworkQuantumSideInfo.ket"><code>GuessworkQuantumSideInfo.ket</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ket([T = Float64], i::Integer, d::Integer) -&gt; SparseVector{Complex{T}}</code></pre><p>Create a vector representing the <code>i</code>th computational basis vector in dimension <code>d</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ket(1,2)
2-element SparseVector{Complex{Float64},Int64} with 1 stored entry:
  [1]  =  1.0+0.0im

julia&gt; collect(ans)
2-element Array{Complex{Float64},1}:
 1.0 + 0.0im
 0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/quantum_states.jl#LL2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.bra" href="#GuessworkQuantumSideInfo.bra"><code>GuessworkQuantumSideInfo.bra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bra([T = Float64], i::Integer, d::Integer) -&gt; SparseVector{Complex{T}}&#39;</code></pre><p>Create a dual vector representing the bra associated to <code>i</code>th computational basis vector in dimension <code>d</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; bra(1,2)
1×2 LinearAlgebra.Adjoint{Complex{Float64},SparseVector{Complex{Float64},Int64}}:
 1.0-0.0im  0.0-0.0im

julia&gt; collect(ans)
1×2 Array{Complex{Float64},2}:
 1.0-0.0im  0.0-0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/quantum_states.jl#LL22-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.BB84_states" href="#GuessworkQuantumSideInfo.BB84_states"><code>GuessworkQuantumSideInfo.BB84_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">BB84_states([T::Type = Float64])</code></pre><p>Generates the BB84 states <code>|0⟩</code>, <code>|1⟩</code>, <code>|-⟩</code>, and <code>|+⟩</code>, for use in <a href="#GuessworkQuantumSideInfo.guesswork"><code>guesswork</code></a> or other functions. The numeric type can be optionally specified by the argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/quantum_states.jl#LL57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.iid_copies" href="#GuessworkQuantumSideInfo.iid_copies"><code>GuessworkQuantumSideInfo.iid_copies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iid_copies(ρBs::AbstractVector{&lt;:AbstractMatrix}, n::Integer) -&gt; Vector{Matrix}</code></pre><p>Create a vector of all states of the form <span>$ρ_1 \otimes \dotsm \otimes ρ_n$</span> where the <span>$ρ_i$</span> range over the set <code>ρBs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/quantum_states.jl#LL75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.randdm" href="#GuessworkQuantumSideInfo.randdm"><code>GuessworkQuantumSideInfo.randdm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randdm([T = Float64], d)</code></pre><p>Generates a density matrix with numeric type <code>Complex{T}</code>, of dimension <code>d</code> at random.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; randdm(2)
2×2 Array{Complex{Float64},2}:
 0.477118+0.0im        0.119848-0.0371569im
 0.119848+0.0371569im  0.522882+0.0im      </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/quantum_states.jl#LL138-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.randprobvec" href="#GuessworkQuantumSideInfo.randprobvec"><code>GuessworkQuantumSideInfo.randprobvec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randprobvec([T=Float64], d)</code></pre><p>Generates points of type <code>T</code>, uniformly at random on the standard <code>d-1</code> dimensional simplex using an algorithm by <a href="http://www.cs.cmu.edu/~nasmith/papers/smith+tromble.tr04.pdf">Smith and Tromble</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; randprobvec(3)
3-element Array{Float64,1}:
 0.24815974900033688
 0.17199716455672287
 0.5798430864429402 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/quantum_states.jl#LL102-L117">source</a></section></article><h2 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.pmfN" href="#GuessworkQuantumSideInfo.pmfN"><code>GuessworkQuantumSideInfo.pmfN</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pmfN(data; tol = 1e-5) -&gt; Vector</code></pre><p>Compute the probability mass function for the number of guesses <code>N</code>, given a strategy. The <code>n</code>th entry of the output vector gives the probability for guessing the correct answer on the <code>n</code>th try, for <code>n = 1 : K</code>. If the number of allowed guesses, <code>K</code>, is smaller than <code>length(p)</code>, then there is an additional last entry which gives the probability of never guessing the correct answer.</p><ul><li><code>data</code> should be a <code>NamedTuple</code> with entries for <code>p</code>, <code>ρBs</code>, <code>Es</code>, <code>K</code>, and <code>povm_outcomes</code></li><li><code>tol</code> provides a tolerance above which to warn about imaginary or negative probabilities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/analyze_measurements.jl#LL1-L15">source</a></section></article><h2 id="Ellipsoid-algorithm-functions-1"><a class="docs-heading-anchor" href="#Ellipsoid-algorithm-functions-1">Ellipsoid algorithm functions</a><a class="docs-heading-anchor-permalink" href="#Ellipsoid-algorithm-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.default_init" href="#GuessworkQuantumSideInfo.default_init"><code>GuessworkQuantumSideInfo.default_init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_init(p, ρBs, c, dB, init_noise) -&gt; NamedTuple</code></pre><p>Choose an initial center <code>x</code> and shape <code>P</code> of the ellipse such that the solution is guaranteed to be inside the ellipse. The initial point is chosen to correspond to <code>c[1]*ρB + noise</code> where <code>ρB</code> is the average state, and <code>noise</code> is a small perturbation whose norm is governed by <code>init_noise</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/ellipsoid/ellipsoid_algorithm.jl#LL48-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.EllipsoidProblem" href="#GuessworkQuantumSideInfo.EllipsoidProblem"><code>GuessworkQuantumSideInfo.EllipsoidProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EllipsoidProblem</code></pre><p>Stores settings and all mutable state of the ellipsoid method. This allows, e.g.</p><pre><code class="language-julia">results = guesswork_ellipsoid(p, ρBs; tol=1e-3, nl_solver = ...)
# inspect `out.optval`, etc
# Continue to solve with a tighter solution tolerance:
results2 = ellipsoid_algorithm!(results.prob; tol=1e-4)</code></pre><p>See <a href="#GuessworkQuantumSideInfo.guesswork_ellipsoid"><code>guesswork_ellipsoid</code></a> for the possible keyword arguments for constructing an <code>EllipsoidProblem</code>, which may be constructed by e.g. <code>EllipsoidProblem(p, ρBs; nl_solver = ..., kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.invherm" href="#GuessworkQuantumSideInfo.invherm"><code>GuessworkQuantumSideInfo.invherm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">invherm(M::AbstractMatrix) -&gt; Vector</code></pre><p>Creates a real vector <code>v</code> representation of a complex Hermitian matrix <code>M</code>. These are related by a linear isometry (with respect to the 2-norm). See also <a href="#GuessworkQuantumSideInfo.herm"><code>herm</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">M = Hermitian(rand(4,4) + im*rand(4,4))
v = invherm(M)

norm(v, 2) ≈ norm(M, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/ellipsoid/ellipsoid_algorithm.jl#LL377-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.herm" href="#GuessworkQuantumSideInfo.herm"><code>GuessworkQuantumSideInfo.herm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">herm(M::AbstractVector) -&gt; Hermitian</code></pre><p>Creates the complex Hermitian matrix <code>M</code> represented by the real vector <code>v</code>.  See also <a href="#GuessworkQuantumSideInfo.invherm"><code>invherm</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">v = rand(16)
M = herm(M)

norm(v, 2) ≈ norm(M, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/ellipsoid/ellipsoid_algorithm.jl#LL415-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.ellipsoid_algorithm!" href="#GuessworkQuantumSideInfo.ellipsoid_algorithm!"><code>GuessworkQuantumSideInfo.ellipsoid_algorithm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ellipsoid_algorithm!(f::EllipsoidProblem; tol=nothing, max_time=nothing)</code></pre><p>Run the ellipsoid algorithm on the <a href="#GuessworkQuantumSideInfo.EllipsoidProblem"><code>EllipsoidProblem</code></a> <code>f</code>. Optionally, pass the keyword argument <code>tol</code> or <code>max_time</code> to update these parameters of <code>f</code> before running.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/GuessworkQuantumSideInfo.jl/blob/bb77988c5e3876f31e29b212139bffb4e5180251/src/ellipsoid/ellipsoid_algorithm.jl#LL208-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuessworkQuantumSideInfo.PermutationIterator" href="#GuessworkQuantumSideInfo.PermutationIterator"><code>GuessworkQuantumSideInfo.PermutationIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PermutationIterator(D::AbstractMatrix; timer=nothing, rtol=1e-6)</code></pre><p>Iterates over permutations and weights to form a decomposition of a doubly stochastic matrix <code>D</code>, known as the Birkhoff–von Neumann decomposition.</p><p>Optionally, specify the keyword arguments</p><ul><li><code>timer</code>: a TimerOutputs.jl timer</li><li><code>rtol</code>: (relative tolerance) for comparing <code>α_i</code> to <code>1</code> to see if all the permutations have been found.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia"># Construct a `d` by `d` doubly stochastic matrix
d = 4
α_init = rand(5)
α_init = α_init / sum(α_init)
D = sum( α_init[i]*I(d)[randperm(d), :] for i = 1:5 )

# Reconstruct it from permutations
D_reconstruct = zero(D)
for (π_i, α_i) in PermutationIterator(D)
    P_i = I(d)[π_i, :]
    global D_reconstruct += α_i * P_i
end
@test D_reconstruct ≈ D</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L29">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/">Examples »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 7 June 2020 00:56">Sunday 7 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
